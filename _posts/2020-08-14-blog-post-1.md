---
title: 'Google Summer of Code 2020'
date: 2020-08-14
permalink: /posts/2020/08/gsoc-final-evaluation/
tags:
  - Google Summer of Code 2020
  - Boost C++
  - Boost.Real
  - C++17
  - arbitrary-precision arithmetic
  - numerical computing
---

# Bringing Boost.Real to review-ready state
<img src='/images/boost_logo.png' alt="boost_logo.png" style="horizontal-align:middle;margin:0px 50px">

## Boost.Real Documentation
- [Project Documentation](https://boostgsoc18.github.io/Real/doc/html/index.html)
## Project Details
- __Source__ __Code:__ [https://github.com/BoostGSoC20/Real](https://github.com/BoostGSoC20/Real).<br>
- __Foundational idea behind Boost.Real:__ [Blog](https://medium.com/@laobelloli/boost-real-9e2dfbfbed5b) by Laouen Belloli
- __Contributors:__ Laouen Belloli (author), Sagnik Dey, Kimberly Swanson, Kishan Shukla, Vikram Chundawat.<br>
- __Mentors:__ Damian Vicino, Laouen Belloli.<br>
- __Previous__ __work:__ <br>
	- [https://medium.com/@laobelloli/boost-real-9e2dfbfbed5b](https://medium.com/@laobelloli/boost-real-9e2dfbfbed5b) (work done by Laouen Belloli during GSoC'18 under the guidance of Damian Vicino)
	- [https://sagnikdey92.github.io/GSoC](https://sagnikdey92.github.io/GSoC) (work done by Sagnik Dey during GSoC'19 under the guidance of Damian Vicino and Laouen Belloli)
	- [https://universenox.github.io/gsoc19_Final_Eval](https://universenox.github.io/gsoc19_Final_Eval) (work done by Kimberly Swanson during GSoC'19 under the guidance of Damian Vicino and Laouen Belloli)
- __Current__ __work:__ <br>
	- This is the report of my work during GSoC'20 under the guidance of Damian Vicino and Laouen Belloli.
	- [https://medium.com/@vikram2000b/56b2582773d3](https://medium.com/@vikram2000b/56b2582773d3) Report of Vikram's work during GSoC'20 under the guidance of Damian Vicino and Laouen Belloli.

## Introduction
__Boost.Real__ is a C++17 library which aims at developing numerical data-type for real number representation. The library provides the flexibility of performing __arbitrary-precision__ __arithmetic__. The foundational work was done by __Laouen__ __belloli__ in GSoC'18, after that, several improvements and new additions were made in GSoC'19 by Sagnik Dey and Kimberly Swanson. For GSoC'20, I and Vikram Chundawat were selected to finish the details and add few functionalities and hence make the library review-ready. Since Vikram and mine's proposal had several overlaps, we distributed the work among ourselves. After the distribution, I got following tasks: <br>
- Changing internal base of Boost.Real numbers to a more efficient value.
- Implementation of optimized long division algorithm.
- Implementation of division operator.
- Implementation of integral power operation.
- Implementation of method to evaluate Pi digits.
- Implementaion of % operator.
- Implementation of Karatsuba Multiplication algorithm.
- Implementation of tests and documentation.  <br>
Before the start of official coding period, we decided on not changing the base of the internal representation as changing it would make few operations more expensive resulting in poor performance.

## Phase I

__Milestones:__<br>
- Implementation of long division algorithm.
- Implementation of division operator.
- Implementation of integral power operation.
- Adding tests and documentation.

### Long division algorithm
Long division was already implemented in the library for base 10, since it was required for the purpose of base change. I had to implement it for any general base as I was going to need it while implementing % operator.  
I used __Knuth's long division algorithm__ as it is quite efficient and easy to implement as well. The Knuth's algorithm optimizes the part where we search for quotient digit (can be anything between 0 to base - 1) in the traditional algorithm. In the traditional algorithm, the search is performed linearly from 0 to Base - 1 making the complexity O(base) (a naive optimization would be to use binary search) whereas the Knuth's algorithm does this in constant time, which provides significant optimization as our internal base increases (our internal base can go upto 10<sup>18</sup>).   
Initial Commit regarding Knuth's long division: [https://github.com/BoostGSoC20/Real/commit/25f1a06a7ea91bed2413a6417f842ed10dee7c3a](https://github.com/BoostGSoC20/Real/commit/25f1a06a7ea91bed2413a6417f842ed10dee7c3a)  
Refrence to Knuth's Algorithm: algorithm D of section 4.3.2 of volume 2 of __The Art of Computer Programming by D. E. Knuth__.  

### Division Operator
This was the most important task in bringing the library to review-ready state. I used Newton-Raphson method for the division algorithm, it involves evaluating reciprocal of the divisor and then multiplying it with the dividend to get the result. The method is quite efficient because of the quadratic convergence of the Newton-Raphson algorithm. The initial guess that I used for Newton-Raphson algorithm involved division therefore I implemented an approximate division algorithm to evaluate the initial guess. Later on the initial guess can replaced with something that doesn't involve division.  
Intial commit regarding division operator: [https://github.com/BoostGSoC20/Real/commit/599890e5fdf9290bb1197d7b054d0517a18f58a3](https://github.com/BoostGSoC20/Real/commit/599890e5fdf9290bb1197d7b054d0517a18f58a3)  

### Integral Power Operation
Integral Power was implemented as new operation between two reals. The implementation was based on const_precision_iterators which makes it more general as were the other operations already present. Binary exponentiation was used to evaluate the powers, making the complexity O(C * log(exponent)) where C is the time taken to multiply two reals.  
Intial commit regarding integral power operation: [https://github.com/BoostGSoC20/Real/commit/84f36e9e2451f15d1ebf42178944e91eb34b7147](https://github.com/BoostGSoC20/Real/commit/84f36e9e2451f15d1ebf42178944e91eb34b7147)  


## Phase II 

__Milestones:__<br>
- Implementing method to evaluate digits of Pi.
- Implementing % operator.
- Implementing calculation of few digits of real_algorithm number during compile time 

### Pi
Pi digits were calculated using Chudnovsky algorithm. The implementation is not the most efficient one therefore after few digits the algorithm runs slow. Chudnovsky algorithm is an iterative algorithm which is being used to calculate the n<sup>th</sup> digit of the real_algorithm number. There are redundant calculations being performed as for calculating (n + 1)<sup>th</sup> digit, the algorithm recalculates the previously calculated values as this time it needs more precise values than previous. There is an algorithm which calculates n<sup>th</sup> digit without calculating previous digits, but the algorithm gives output in hexadecimal base, which doesn't fulfill our requirement.  
Following is the implementation of Chudnovsky algorithm:  
<pre> <code>
T pi_nth_digit(unsigned int n) {
	// Chudnovsky Algorithm
	// pi = C * ( sum_from_k=0_to_k=x (Mk * Lk / Xk) )^(-1) 
	// increasing x you get more precise pi

	static const boost::real::real_explicit<T> real_k("6");
	static const boost::real::real_explicit<T> real_m("1");
	static const boost::real::real_explicit<T> real_l("13591409");
	static const boost::real::real_explicit<T> real_l0("545140134");
	static const boost::real::real_explicit<T> real_x("1");
	static const boost::real::real_explicit<T> real_x0("-262537412640768000");
	static const boost::real::real_explicit<T> real_s("13591409");

	static exact_number<T> L0 = real_l0.get_exact_number();
	static exact_number<T> X0 = real_x0.get_exact_number();

	bool nth_digit_found = false;
	bool first_iteration_over = false;

	exact_number<T> iteration_number = one;
	exact_number<T> prev_pi;
	exact_number<T> pi;
	exact_number<T> error;
	const exact_number<T> max_error(std::vector<T> {1}, -(n + 1), true);

	do {  
	    exact_number<T> temp = K * K * K - _16 * K;
	    temp.divide_vector(iteration_number * iteration_number * iteration_number, n + 1, true);
	    M *= temp;
	    X *= X0;
	    L += L0;
	    K += _12;

	    temp = M * L;
	    temp.divide_vector(X, n + 1, false);
	    S += temp;

	    temp = C;
	    temp.divide_vector(S, n + 1, false);

	    pi = temp;
	    if (!first_iteration_over) {
		prev_pi = pi;
		first_iteration_over = true;
		iteration_number += one;
	    } else {
		error = pi - prev_pi;
		error.positive = true;

		if (error < max_error) {
		    nth_digit_found = true;
		}
		iteration_number += one;
		prev_pi = pi;
	    }

	} while (!nth_digit_found);

	return pi[n];
}
</code> </pre>
Intial commit regarding Pi: [https://github.com/BoostGSoC20/Real/commit/34ac759f128cd2ffb5d684c5ff7a5a0e54025360](https://github.com/BoostGSoC20/Real/commit/34ac759f128cd2ffb5d684c5ff7a5a0e54025360)  

### % operator
As % operator is only defined for integers, this operator was overloaded by Vikram in his integer_number class. The operator used the Knuth's long division algorithm to find the remainder.

## Phase III

__Milestone:__<br>
- Implement Karatsuba algorithm.
- Tests Documentation.
### Karatsuba algorithm
I implemented the Karatsuba algorithm which improved the performance of the multiplication operation for vectors of much bigger sizes. The implementation is bit more optimised than the traditional implementation as we are not storing zeroes (required to make the length of operands equal) in vectors. This small optimisation saves a lot of memory as well as time. Benchmarking of the algorithm was done by multiplying incrementally larger examples using both standard multiplication algorithm and Karatsuba algorithm and comparing the performances. The examples used for the benchmarking purpose were vectors of same length, in general the benchmarking becomes difficult if we consider examples of different sizes which is more practical situation.  
Initial commit regarding Karatsuba algorithm:   [https://github.com/BoostGSoC20/Real/commit/83e43dede5e2d101240777fc1eb0dd14a64f3eba](https://github.com/BoostGSoC20/Real/commit/83e43dede5e2d101240777fc1eb0dd14a64f3eba)
## Commit History  
[Here](https://github.com/BoostGSoC20/Real/commits?author=kishanshukla-2307) is the list of all the commits that were merged in Boost.Real master during or before the start of GSoC 2020 coding period.
